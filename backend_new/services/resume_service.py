from __future__ import annotations

"""Resume generation utilities.

Centralizes logic for:
 - Loading base resume text: uploaded resume (stored in run.metadata_json) > sample_resume.txt > placeholder
 - Generating per-job tailored resume snippets

All resume customization length-capped to 20k chars to stay within typical DB/text constraints.
"""

from pathlib import Path
from typing import Optional
import json

from app.models import PipelineRun, ScrapedJob

PLACEHOLDER_RESUME_TEXT = "PLACEHOLDER RESUME TEXT - upload a real resume for better tailoring."


def _find_sample_resume() -> Optional[str]:
    """Attempt to locate and read sample_resume.txt searching from project root upward.

    Returns file contents or None.
    """
    # Search up to 4 directory levels from this file for sample_resume.txt
    for p in [Path.cwd()] + list(Path(__file__).resolve().parents)[:4]:  # cwd first, then parents
        candidate = p / "sample_resume.txt"
        if candidate.is_file():
            try:
                return candidate.read_text(encoding="utf-8")[:20000]
            except Exception:  # noqa: BLE001
                return None
    return None


def load_base_resume_text(run: PipelineRun) -> str:
    """Return best available base resume text for a run.

    Priority:
      1. run.metadata_json['resume_text'] if present
      2. sample_resume.txt file in project tree
      3. PLACEHOLDER_RESUME_TEXT constant
    """
    if run.metadata_json:
        try:
            meta = json.loads(run.metadata_json)
            txt = meta.get("resume_text")
            if txt:
                return txt[:20000]
        except Exception:  # noqa: BLE001
            pass
    sample = _find_sample_resume()
    if sample:
        return sample
    return PLACEHOLDER_RESUME_TEXT


def tailor_resume_for_job(base_text: str, job: ScrapedJob) -> str:
    """Produce a tailored resume variant/snippet for a job.

    Strategy: Append a short tailoring note referencing job title/company and a trimmed description snippet.
    """
    desc = (job.description or "").strip().splitlines()
    # Take up to first 3 non-empty lines for context
    snippet_lines = [l.strip() for l in desc if l.strip()][:3]
    snippet = " ".join(snippet_lines)[:600]
    tailoring = f"\n\n[Autogenerated tailoring for {job.title} at {job.company or 'Company'}]\n{snippet}"
    return (base_text + tailoring)[:20000]


def generate_resumes_for_jobs(run: PipelineRun, jobs: list[ScrapedJob], force: bool = True) -> tuple[int, int]:
    """Generate resume_custom for each job.

    Returns (processed, skipped).
    """
    base_text = load_base_resume_text(run)
    processed = 0
    skipped = 0
    for j in jobs:
        if not force and j.resume_custom:
            skipped += 1
            continue
        try:
            j.resume_custom = tailor_resume_for_job(base_text, j)
            processed += 1
        except Exception:  # noqa: BLE001
            skipped += 1
    return processed, skipped

__all__ = [
    "load_base_resume_text",
    "tailor_resume_for_job",
    "generate_resumes_for_jobs",
    "PLACEHOLDER_RESUME_TEXT",
]
